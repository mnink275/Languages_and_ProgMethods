#include <iostream>
#include <cstring>

class Time {    // Класс является абстрактным типом данных (АТД).
public:     // Спецификатор доступа, открытые элементы.
    Time();     // Конструктор. В нём можно инициализировать значения данных-элементов (атрибутов).
    void setTime(int, int, int);  // Открытые функции (методы класса) - это интерфейс класса, они доступны клиентам.
    void printMilitary();   // Обе функции являются прототипами (происходит только их объявление).
private:        // Спецификатор доступа, скрывает элементы от клиентов.
    int hour;       // Данные-элемента класса используются в функциях-элементах.
    int minute;
    int second;
};

Time::Time() {      // Time::ФУНКЦИЯ позволяет использовать данные-элементы без бинарной операции разрешения области дейстия (::).
    hour = minute = second = 0;
}

void Time::printMilitary() {        // Функция print не получает аргументов. Дело в том, что она неявно знает, что использует данные-элементы объекта типа Time;
    std::cout << hour << ":" << minute << ":" << second << std::endl;
}

void Time::setTime(int h, int m, int s) {
    hour = (h > 0 && h <= 24) ? h : 0;      // Условный тернарный оператор.
    minute = (m > 0 && m <= 60) ? m : 0;
    second = (s > 0 && s <= 60) ? s : 0;
}

int main()
{  
    Time t;     // t является объектом типа Time.

    std::cout << "Initial time value: ";
    t.printMilitary();      // Вызов функции-элемента класса через точку, как в питоне.

    t.setTime(16,10,33);
    std::cout << "Current time value: ";
    t.printMilitary();

    return 0;
}
// Икапсулируя операции, скрывая реализацию, мы исключаем возможность для других частей программы оказаться
// зависимыми от особенностей реализации. Реализация меняется, интерфейс остаётся тем же.